#!/usr/bin/python
# vim: set sw=4 st=4 ai expandtab:

import os
import sys
import argparse
from datetime import datetime
from datetime import timedelta
from dbi3_log_conversion import Dbi3LogConversion, conv_ft_to_M

__version__ = '0.4.alpah1'


if __name__ == '__main__':
    fields_choice = ['ROC', 'TOPT', 'AMBT', 'DIFF', 'SOG', 'COG', 'BATM', 'BRDT']
    fields_default = ['AMBT', 'TOPT', 'DIFF']
    do_field = {}

    parser = argparse.ArgumentParser(description="Convert DBI3 log file(s) to KML format.",
                                     epilog="  Output filename is the input root name with a .kml extension.  The " +
                                     "optional unicsv format can be converted to other useful formats (such as GPX) " +
                                     "by the GPSBabel application")
    parser.add_argument('filename', type=str, nargs='+',
                        help='DBI3 log filename')
    parser.add_argument('--fields', action='store', default=fields_default,
                        type=lambda s: s.split(','),
                        help='Which DBI3 data fields should be included in the KML output, ' +
                             'default={}, choices={}, ALL turns on all fields'
                             .format(','.join(fields_default), ','.join(fields_choice)))
    parser.add_argument('--altitudemode', action='store', default='absolute',
                        choices=['absolute', 'clamptoground', 'relative'],
                        help='display mode for track altitude, default=absolute')
    parser.add_argument('--useMetric', action='store_true', default=False,
                        help='For additional profile graph data fields use meters per second for rate of climb, ' +
                             'kilometers per hour for speed, ' +
                             'Celsius for temperature, and meters for altitude.  ' +
                             'default=FPM, MPH, Fahrenheit, feet.  NOTE: Google Earth config controls ' +
                             'the map display units for Track Elevation and Speed.')
    parser.add_argument('--offset', action='store', dest='altitude_offset', type=float, default=0.0,
                        help='correction offset to apply to the pressure altitude, default=0.0')
    parser.add_argument('--dest', '-d', action='store', dest='dest_dir', default=None,
                        help='destination path for the output files. Defaults to the' +
                             ' path of the first log filename')
    parser.add_argument('--csv', action='store_true', default=False,
                        help='enable unicsv output file')
    parser.add_argument('--verbose', action='store_true', default=False,
                        help='verbose output during processing')
    parser.add_argument('--version', '-V', action='version', version='%(prog)s ('+__version__+')')
    args = parser.parse_args()
    # Verifiy the fields list and set the field names in a boolean dictionary
    for fn in fields_choice:
        do_field[fn] = False
    if 'ALL' in args.fields:
        # Special case, turns on all fields
        args.fields = fields_choice
    for fn in args.fields:
        if fn not in fields_choice:
            print 'error: argument --fields: invalid choice: \'{}\' (choose from {})'.format(fn, fields_choice)
            sys.exit(-1)
        else:
            do_field[fn] = True

    # Adjust altitude_offset from feet to meters for KML offset
    args.altitude_offset = conv_ft_to_M(args.altitude_offset)

    # Verify destination path, or construct destination from first log file path
    if args.dest_dir is None:
        dest_dir = os.path.dirname(args.filename[0])
    elif not os.path.isdir(args.dest_dir):
        print '-d ' + args.dest_dir + " path does not exists"
        sys.exit(-1)
    else:
        dest_dir = args.dest_dir

    for fn in args.filename:
        filename = os.path.basename(fn)
        filename, f_ext = os.path.splitext(filename)
        base_name = os.path.join(dest_dir, filename)
        print ''
        print 'Basename: ' + base_name
        filename = base_name + '.csv'
        if args.csv:
            csv_file = open(filename, 'w')
        else:
            csv_file = None

        dbi3 = Dbi3LogConversion(fn, altitudemode=args.altitudemode,
                                 altitude_offset=args.altitude_offset, verbose=args.verbose,
                                 fields_choice=do_field, kml_use_metric=args.useMetric)
        dbi3.kml_convert(base_name)
        if csv_file is not None:
            csv_file.close()
