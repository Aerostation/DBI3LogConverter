#!/usr/bin/python
# vim: set sw=4 st=4 ai expandtab:
"""Drive the DBI3 log downloads and conversions to KML

The is currently a default to new files.  I has no selection capability yet.
"""
import os
import sys
import argparse
import cmd
import re
from datetime import datetime, timedelta, tzinfo
import json
import collections
from dbi3_log_conversion import *
from dbi3_log_downloads import *

__version__ = '0.1.alpah1'

dbi_conf = os.path.join(os.path.expanduser('~'), '.DBI3config')
print 'CONF file:{}'.format(dbi_conf)
log_path = '/tmp/DBI3'
kml_path = '/tmp/DBI3/kml'
com_port = '/dev/ttyDBI3'
verbose = True

# TODO the concept of "new" files should be based on the latest stored log/kml, not simply old missing files.

def convert_new_logs(log_path, kml_path):
    """Convert new DBI3 logs to kml output

    For each DBI3 log file, if the corresponding kml file does not exists,
    run the conversion.

    :param str log_path: path containing DBI3 log files
    :param str kml_path: path containing DBI3 kml files
    :return:
    """
    conv_list = Dbi3KmlList(log_path, kml_path)
    conv_list.refresh_list
    for le in conv_list.conversion_list:
        print 'RDT name:{}  new_file:{}  override:{}'.format(le.log_name,
                                                             'Y' if le.new_file else 'N',
                                                             le.override)
        if le.new_file:
            dbi3_obj = Dbi3LogConversion(le.log_filename, verbose=verbose)
        rtn, rtn_str = dbi3_obj.kml_convert(le.kml_filename)
        if rtn < 0:
            print 'Convert {} to {} FAILED: {}'.format(le.log_name, le.kml_name, rtn_str)
        elif rtn > 0 and verbose:
            print 'Convert {} : {}'.format(le.log_name, rtn_str)
        elif rtn == 0:
            print 'Convert {}\n{}'.format(le.log_name, rtn_str)

    # prog = re.compile('^(\d{4})_(\d\d)_(\d\d)_(\d\d)_(\d\d)_(\d\d)_DBI3.log$')
    # for item in sorted(os.listdir(log_path)):
    #     log_filename = os.path.join(log_path, item)
    #     if os.path.isfile(log_filename):
    #         match = prog.match(item)
    #         if match:
    #             kml_name = match.expand('\\1\\2\\3_\\4\\5_DBI3')
    #             kml_filename = os.path.join(kml_path, kml_name)
    #             log_metaname = os.path.join(log_path, '.' + item[0:-4])
    #             if not os.path.isfile(kml_filename + '.kml'):
    #                 if os.path.isfile(log_metaname):
    #                     # meta file to override some conversion settings
    #                     with open(log_metaname, 'r') as meta:
    #                         data = json.load(meta)
    #                     print 'RDT conversion meta = {}'.format(data)
    #
    #                 dbi3_obj = Dbi3LogConversion(log_filename, verbose=True)
    #                 rtn, rtn_str = dbi3_obj.kml_convert(kml_filename)
    #                 if rtn < 0:
    #                     print 'Convert {} to {} FAILED: {}'.format(item, kml_name, rtn_str)
    #                 elif rtn > 0 and verbose:
    #                     print 'Convert {} : {}'.format(item, rtn_str)
    #                 elif rtn == 0:
    #                     print 'Convert {}\n{}'.format(item, rtn_str)


def process_dbi():
    if not os.path.isdir(log_path):
        print "Log file path {} does not exist.".format(log_path)
        exit()
    if not os.path.isdir(kml_path):
        print "KML file path {} does not exist.".format(kml_path)
        exit()

    try:
        # log list elements contain list 'startRad26, stopRad26, start_dt, stop_dt, log_filename'
        # The log list automatically marks new logs as selected for download.
        down_load = DBI3LogDownload(log_path, com_port, verbose)
        log_list = down_load.get_DBI3_log_list()

        if log_list is not None:
            down_load.download_selected_logs(log_list)

    except IOError as e:
        print 'IO error with DBI3 on {}: {}'.format(com_port, e.message)
        print 'Skip DBI3 log downloads'
        # Continue on with any log conversions

    convert_new_logs(log_path, kml_path)


CLI_new_logs = True
CLI_age_limit = None
CLI_skip_invalid = True


class Dbi3InteractiveCommandLine(cmd.Cmd):
    prompt = '(DBI3) '

    def preloop(self):
        self.do_help('')

    def do_config(self, line):
        """Set port, log path, kml path"""
        print 'Not implemented yet'

    def do_filter(self, line):
        """Filter DBI3 logs in the list - all|[new,YYYYMMDDhhmm]"""
        global CLI_new_logs
        global CLI_age_limit
        global CLI_skip_invalid
        if line == '':
            print 'new_logs:{}  age_limit:{}  valid_only:{}'.format(CLI_new_logs, CLI_age_limit, CLI_skip_invalid)
            return
        for ln in line.split(','):
            ln.strip()
            if ln == 'all':
                CLI_new_logs = False
                CLI_age_limit = None
                CLI_skip_invalid = False
            elif ln == 'new':
                CLI_new_logs = True
                CLI_age_limit = None
            elif ln == 'valid':
                CLI_skip_invalid = True
            elif ln == 'invalid':
                CLI_skip_invalid = False
            else:
                # Try to parse an age limit string
                try:
                    dt = datetime.strptime(ln, '%Y%m%d%H%M')
                    CLI_age_limit = dt
                except ValueError as e:
                    print 'ERROR: unknown filter time {} : {}'.format(ln, e.message)
                    continue

    def do_Logs(self, line):
        """Read and select logs for download/delete."""
        try:
            Dbi3LogListCommands().cmdloop()
        except IOError as e:
            print 'RDT Can not access DBI3: {}'.format(e.message)

    def do_KML(self, line):
        """Select and convert logs to KML."""
        Dbi3KmlConversionCommands().cmdloop()

    def do_EOF(self, line):
        """Exit"""
        return True

    def do_exit(self, line):
        """Exit the application"""
        return True


class Dbi3LogListCommands(cmd.Cmd):
    global CLI_new_logs
    global CLI_age_limit
    global CLI_skip_invalid
    prompt = '(DBI3:Logs) '
    down_load = None
    my_list = []  # this contains our selection flag and the Log list element

    def preloop(self):
        self.down_load = DBI3LogDownload(log_path, com_port, verbose, age_limit=CLI_age_limit, valid_only=CLI_skip_invalid)
        self.my_list = []
        for le in self.down_load.get_DBI3_log_list(new_logs_only=CLI_new_logs):
            self.my_list.append([le.new_file, le])
        self.do_help('')

    def do_refresh(self, line):
        """Re-read the DBI3 log list"""
        self.log_list = self.down_load.get_DBI3_log_list()

    def do_list(self, line):
        """Display the DBI3 logs available for download - all|selected"""
        only_sel = line == 'selected'
        for i, le in enumerate(self.my_list):
            if only_sel == False or le[0] == True:
                print "{:2d}  {} {}{}  delta:{}". \
                    format(i,
                           '*' if le[0] else ' ',
                           le[1].log_name,
                           '(new)' if le[1].new_file else '     ',
                           le[1].end_dt - le[1].start_dt)

    def do_select(self, line):
        """Select/deselect LOG list rows for KML conversion. [all, none, new, #, #-#, -#]"""
        process_select_range(line, self.my_list)
        # ln = line.lower()
        # for line in ln.split(','):
        #     line = line.strip()
        #     print 'RDT line {}'.format(line)
        #     sel = None
        #     sel_new = False
        #     if 'all' in line: sel = True
        #     elif 'none' in line: sel = False
        #     elif 'new' in line: sel_new = True
        #     if sel is not None or sel_new:
        #         for le in self.my_list:
        #             if sel_new == False:
        #                 le[0] = sel
        #             else:
        #                 le[0] = le[1].new_file
        #         continue
        #     # not a full sweep so check for specific numbers
        #     # Leading '-' indicates this is a deselect
        #     # TODO collect all indicies before changing anything
        #     if line[0] == '-':
        #         line = line[1:]
        #         sel = False
        #     else:
        #         sel = True
        #     sel_spec = line
        #     sel_spec = sel_spec.strip()
        #     rng_spec = sel_spec.split('-')
        #     print 'RDT rng_spec {}'.format(rng_spec)
        #     if rng_spec[0] == '':
        #         print "ERROR: bad range specification {}".format(sel_spec)
        #     beg_idx = int(rng_spec[0])
        #     if len(rng_spec) == 1:
        #         end_idx = beg_idx + 1
        #     else:
        #         end_idx = int(rng_spec[1]) + 1
        #     if beg_idx < 0 or beg_idx >= len(self.my_list) or end_idx <= beg_idx or end_idx > len(self.my_list):
        #         print 'ERROR: valid select index range is 0 through {}'.format(len(self.my_list)-1)
        #         return
        #     for i in range(beg_idx, end_idx):
        #         self.my_list[i][0] = sel

    def help_select(self):
        print 'Select/deselect LOG list rows for KML conversion.'
        print 'Usage: select all|none|new|[-]#|#-#[,#|#-#...]'
        print '  all - select all rows'
        print '  none - deselect all rows'
        print '  new - select only new rows, deselect all others'
        print '  #    - select a specific row'
        print '  #-#  - select a range of rows, inclusive'
        print '  Multiple numbers,ranges can be specified, seperated by commas'
        print '  If you prefix all number,ranges with "-" it becomes a deselect'

    def do_download(self, line):
        """Download the selected files"""
        for le in self.my_list:
            if le[0]:  # list row is marked as selected
                self.down_load.get_DBI3_log(le[1].name_start)

    def do_delete(self, line):
        """Delete the selected log files on the DBI3"""
        for le in self.my_list:
            if le[0]:  # list row is marked as selected
                print 'RDT - would delete {} {}'.format(le[1].name_start, le[1].log_name)

    def do_EOF(self, line):
        """back to Main menu"""
        return True

    def do_exit(self, line):
        """exit back to Main menu"""
        return True


class Dbi3KmlConversionCommands(cmd.Cmd):
    prompt = '(DBI3:KML) '
    conv_list = None
    my_list = []

    def preloop(self):
        self.conv_list = Dbi3KmlList(log_path, kml_path)
        self.conv_list.refresh_list
        self.my_list = []
        for le in self.conv_list.conversion_list:
            dbi3_obj = Dbi3LogConversion(le.log_filename, verbose=verbose)
            log_stats = dbi3_obj.kml_summary()
            self.my_list.append([le.new_file, le, log_stats])
        # print "RDT {}".format(self.my_list)
        self.do_help('')

    def do_refresh(self, line):
        """Re-read the DBI3 logs available for KML conversion"""
        self.conv_list.refresh_list

    def do_list(self, line):
        """Display the DBI3 logs available for KML conversion"""
        only_sel = line == 'selected'
        for i, le in enumerate(self.my_list):
            print "{:2d}  {} {}{}  override:{}  rcrds:{}  duration:{}".format(i,
                                                         '*' if le[0] else ' ',
                                                         le[1].log_name,
                                                           '(new)' if le[1].new_file else '     ',
                                                         'Y' if le[1].override else ' ',
                                                         le[2].status,
                                                         le[2].gps_end - le[2].gps_start if le[2].status > 0 else '---')

    def do_select(self, line):
        """Select/deselect LOG list rows for KML conversion. [all, none, new, #, #-#, -#]"""
        process_select_range(line, self.my_list)
        # line = line.lower()
        # sel = None
        # sel_new = False
        # if 'all' in line: sel = True
        # elif 'none' in line: sel = False
        # elif 'new' in line: sel_new = True
        # if sel is not None or sel_new:
        #     for le in self.my_list:
        #         if sel_new == False:
        #             le[0] = sel
        #         else:
        #             le[0] = le[1].new_file
        #     return
        # # not a full sweep so check for specific numbers
        # # Leading '-' indicates this is a deselect
        # # TODO collect all indicies before changing anything
        # if line[0] == '-':
        #     line = line[1:]
        #     sel = False
        # else:
        #     sel = True
        # for sel_spec in line.split(','):
        #     sel_spec = sel_spec.strip()
        #     rng_spec = sel_spec.split('-')
        #     if rng_spec[0] == '':
        #         print "ERROR: bad range specification {}".format(sel_spec)
        #     beg_idx = int(rng_spec[0])
        #     if len(rng_spec) == 1:
        #         end_idx = beg_idx + 1
        #     else:
        #         end_idx = int(rng_spec[1]) + 1
        #     if beg_idx < 0 or beg_idx >= len(self.my_list) or end_idx <= beg_idx or end_idx > len(self.my_list):
        #         print 'ERROR: valid select index range is 0 through {}'.format(len(self.my_list)-1)
        #         return
        #     for i in range(beg_idx, end_idx):
        #         self.my_list[i][0] = sel

    def help_select(self):
        print 'Select/deselect LOG list rows for KML conversion.'
        print 'Usage: select all|none|new|[-]#|[-]#-#,[...]'
        print '  all - select all rows'
        print '  none - deselect all rows'
        print '  new - select only new rows, deselect all others'
        print '  #    - select a specific row'
        print '  #-#  - select a range of rows, inclusive'
        print '  Multiple selections can be specified, seperated by commas'
        print '  If you prefix a number,ranges with "-" it becomes a deselect'

    def do_convert(self, line):
        """Convert the currently selected DBI3 logs to KML"""
        for le in self.my_list:
            if le[0]:
                dbi3_obj = Dbi3LogConversion(le[1].log_filename, verbose=verbose)
            rtn, rtn_str = dbi3_obj.kml_convert(le[1].kml_filename)
            if rtn < 0:
                print 'Convert {} to {} FAILED: {}'.format(le[1].log_name, le[1].kml_name, rtn_str)
            elif rtn > 0 and verbose:
                print 'Convert {} : {}'.format(le[1].log_name, rtn_str)
            elif rtn == 0:
                print 'Convert {}\n{}'.format(le[1].log_name, rtn_str)

    def do_EOF(self, line):
        """back to Main menu"""
        return True

    def do_exit(self, line):
        """exint back to Main menu"""
        return True


def process_select_range(line, my_list):
    """Given selection string, process the list to update the select flag

    my_list is a list of lists.  It ccntains the T/F select flag and the dictionary of the actual data
    row.  One of the row elements must be named "new_file" to be used for "new" selection.
    
    :param str line: String containing one or more comma separated selection specs
    :param list my_list: list of rows, each row is a list of two elements, select=T/F and dictionary
    :result: my_list select field is altered as specified
    """
    ln = line.lower()
    for line in ln.split(','):
        line = line.strip()
        sel = None
        sel_new = False
        if 'all' in line:
            sel = True
        elif 'none' in line:
            sel = False
        elif 'new' in line:
            sel_new = True
        if sel is not None or sel_new:
            for le in my_list:
                if sel_new == False:
                    le[0] = sel
                else:
                    le[0] = le[1].new_file
            continue
        # not a full sweep so check for specific numbers
        # Leading '-' indicates this is a deselect
        # TODO collect all indicies before changing anything
        if line[0] == '-':
            line = line[1:]
            sel = False
        else:
            sel = True
        sel_spec = line
        sel_spec = sel_spec.strip()
        rng_spec = sel_spec.split('-')
        if rng_spec[0] == '':
            print "ERROR: bad range specification {}".format(sel_spec)
        beg_idx = int(rng_spec[0])
        if len(rng_spec) == 1:
            end_idx = beg_idx + 1
        else:
            end_idx = int(rng_spec[1]) + 1
        if beg_idx < 0 or beg_idx >= len(my_list) or end_idx <= beg_idx or end_idx > len(my_list):
            print 'ERROR: valid select index range is 0 through {}'.format(len(my_list) - 1)
            return
        for i in range(beg_idx, end_idx):
            my_list[i][0] = sel


if __name__ == "__main__":
    fields_choice = ['ROC', 'TOPT', 'AMBT', 'DIFF', 'SOG', 'COG', 'BATM', 'BRDT']
    fields_default = ['AMBT', 'TOPT', 'DIFF']
    do_field = {}

    parser = argparse.ArgumentParser(description="Convert DBI3 log file(s) to KML format.",
                                     epilog="  Output filename is the input root name with a .kml extension.  The " +
                                            "optional unicsv format can be converted to other useful formats (such as GPX) by " +
                                            "the GPSBabel application")
    parser.add_argument('--interactive', '-i', action='store_true', default=False,
                        help='start interactive command line')
    parser.add_argument('--fields', action='store', default=fields_default,
                        type=lambda s: s.split(','),
                        help='Which DBI3 data fields should be included in the KML output, default={}, choices={}, ALL turns on all fields'
                        .format(','.join(fields_default), ','.join(fields_choice)))
    parser.add_argument('--altitudemode', action='store', default='absolute',
                        choices=['absolute', 'clamptoground', 'relative'],
                        help='display mode for track altitude, default=absolute')
    parser.add_argument('--offset', action='store', dest='altitude_offset', type=float, default=0.0,
                        help='correction offset to apply to the pressure altitude, default=0.0')
    parser.add_argument('-d', action='store', dest='dest_dir', default=None,
                        help='destination path for the output files. Defaults to the' +
                             ' path of the first log filename')
    parser.add_argument('--csv', action='store_true', default=False,
                        help='enable unicsv output file')
    parser.add_argument('--verbose', action='store_true', default=False,
                        help='verbose output during processing')
    parser.add_argument('-V', '--version', action='version', version='%(prog)s (' + __version__ + ')')
    args = parser.parse_args()
    # Verifiy the fields list and set the field names in a boolean dictionary
    for fn in fields_choice:
        do_field[fn] = False
    if 'ALL' in args.fields:
        # Special case, turns on all fields
        args.fields = fields_choice
    for fn in args.fields:
        if fn not in fields_choice:
            print 'error: argument --fields: invalid choice: \'{}\' (choose from {})'.format(fn, fields_choice)
            sys.exit(-1)
        else:
            do_field[fn] = True
    verbose = args.verbose

    # Read the optional config file to override our default settings
    if os.path.isfile(dbi_conf):
        with open(dbi_conf, 'r') as conf_file:
            data = json.load(conf_file)
        if 'log_path' in data: log_path = data['log_path']
        if 'kml_path' in data: kml_path = data['kml_path']
        if 'com_port' in data: com_port = data['com_port']
        if 'verbose' in data: verbose = data['verbose']

    # Adjust altitude_offset from feet to meters for KML offset
    args.altitude_offset = conv_ft_to_M(args.altitude_offset)

    # Verify destination path, or construct destination from first log file path
    #    if args.dest_dir is None:
    #        dest_dir = os.path.dirname(args.filename[0])
    #    elif not os.path.isdir(args.dest_dir):
    #        print '-d ' + args.dest_dir + " path does not exists"
    #        sys.exit(-1)
    #    else:
    #        dest_dir = args.dest_dir

    print 'RDT verbose={} {}'.format(verbose, args.verbose)
    if args.interactive:
        Dbi3InteractiveCommandLine().cmdloop()
    else:
        process_dbi()
