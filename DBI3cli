#!/usr/bin/python
# vim: set sw=4 st=4 ai expandtab:
"""Drive the DBI3 log downloads and conversions to KML

The is currently a default to new files.  I has no selection capability yet.
"""
import os
import sys
import argparse
import re
from datetime import datetime, timedelta, tzinfo
import json
import collections
from dbi3_log_conversion import Dbi3LogConversion, ft_to_M
from dbi3_log_downloads import *

__version__ = '0.1.alpah1'

dbi_conf = os.path.join(os.path.expanduser('~'), '.DBI3config')
log_path = '/tmp/DBI3'
kml_path = '/tmp/DBI3/kml'
com_port = '/dev/ttyDBI3'
verbose = True


def convert_new_logs(log_path, kml_path):
    """Convert new DBI3 logs to kml output

    For each DBI3 log file, if the corresponding kml file does not exists,
    run the conversion.

    :param str log_path: path containing DBI3 log files
    :param str kml_path: path containing DBI3 kml files
    :return:
    """
    prog = re.compile('^(\d{4})_(\d\d)_(\d\d)_(\d\d)_(\d\d)_(\d\d)_DBI3.log$')
    for item in sorted(os.listdir(log_path)):
        log_filename = os.path.join(log_path, item)
        if os.path.isfile(log_filename):
            match = prog.match(item)
            if match:
                kml_name = match.expand('\\1\\2\\3_\\4\\5_DBI3')
                kml_filename = os.path.join(kml_path, kml_name)
                log_metaname = os.path.join(log_path, '.' + item[0:-4])
                if not os.path.isfile(kml_filename + '.kml'):
                    if os.path.isfile(log_metaname):
                        # meta file to override some conversion settings
                        with open(log_metaname, 'r') as meta:
                            data = json.load(meta)
                        print 'RDT conversion meta = {}'.format(data)
                    print 'Convert {} to {}'.format(item, kml_name)

                    dbi3_obj = Dbi3LogConversion(log_filename, verbose=True)
                    dbi3_obj.kml_convert(kml_filename)


def process_dbi():
    if not os.path.isdir(log_path):
        print "Log file path {} does not exist.".format(log_path)
        exit()
    if not os.path.isdir(kml_path):
        print "KML file path {} does not exist.".format(kml_path)
        exit()

    try:
        # log list elements contain list 'startRad26, stopRad26, start_dt, stop_dt, log_filename'
        # The log list automatically marks new logs as selected for download.
        down_load = DBI3LogDownload(log_path, com_port, verbose)
        log_list = down_load.get_DBI3_log_list()

        if log_list is not None:
            down_load.download_selected_logs(log_list)

    except IOError as e:
        print 'IO error with DBI3 on {}: {}'.format(com_port, e.message)
        print 'Skip DBI3 log downloads'
        # Continue on with any log conversions

    convert_new_logs(log_path, kml_path)


if __name__ == "__main__":
    fields_choice = ['ROC', 'TOPT', 'AMBT', 'DIFF', 'SOG', 'COG', 'BATM', 'BRDT']
    fields_default = ['AMBT', 'TOPT', 'DIFF']
    do_field = {}

    parser = argparse.ArgumentParser(description="Convert DBI3 log file(s) to KML format.",
                                     epilog="  Output filename is the input root name with a .kml extension.  The " +
                                            "optional unicsv format can be converted to other useful formats (such as GPX) by " +
                                            "the GPSBabel application")
    parser.add_argument('--fields', action='store', default=fields_default,
                        type=lambda s: s.split(','),
                        help='Which DBI3 data fields should be included in the KML output, default={}, choices={}, ALL turns on all fields'
                        .format(','.join(fields_default), ','.join(fields_choice)))
    parser.add_argument('--altitudemode', action='store', default='absolute',
                        choices=['absolute', 'clamptoground', 'relative'],
                        help='display mode for track altitude, default=absolute')
    parser.add_argument('--offset', action='store', dest='altitude_offset', type=float, default=0.0,
                        help='correction offset to apply to the pressure altitude, default=0.0')
    parser.add_argument('-d', action='store', dest='dest_dir', default=None,
                        help='destination path for the output files. Defaults to the' +
                             ' path of the first log filename')
    parser.add_argument('--csv', action='store_true', default=False,
                        help='enable unicsv output file')
    parser.add_argument('--verbose', action='store_true', default=False,
                        help='verbose output during processing')
    parser.add_argument('-V', '--version', action='version', version='%(prog)s (' + __version__ + ')')
    args = parser.parse_args()
    # Verifiy the fields list and set the field names in a boolean dictionary
    for fn in fields_choice:
        do_field[fn] = False
    if 'ALL' in args.fields:
        # Special case, turns on all fields
        args.fields = fields_choice
    for fn in args.fields:
        if fn not in fields_choice:
            print 'error: argument --fields: invalid choice: \'{}\' (choose from {})'.format(fn, fields_choice)
            sys.exit(-1)
        else:
            do_field[fn] = True

    # Read the optional config file to override our default settings
    if os.path.isfile(dbi_conf):
        with open(dbi_conf, 'r') as conf_file:
            data = json.load(conf_file)
        if 'log_path' in data: log_path = data['log_path']
        if 'kml_path' in data: kml_path = data['kml_path']
        if 'com_port' in data: com_port = data['com_port']
        if 'verbose' in data: verbose = data['verbose']

    # Adjust altitude_offset from feet to meters for KML offset
    args.altitude_offset = ft_to_M(args.altitude_offset)

    # Verify destination path, or construct destination from first log file path
    #    if args.dest_dir is None:
    #        dest_dir = os.path.dirname(args.filename[0])
    #    elif not os.path.isdir(args.dest_dir):
    #        print '-d ' + args.dest_dir + " path does not exists"
    #        sys.exit(-1)
    #    else:
    #        dest_dir = args.dest_dir

    process_dbi()
